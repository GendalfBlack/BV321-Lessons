from tkinter import *
import random as r

# функція що додаватиме нове число у список
# приймає:
# value значення з текстового поля введення
# label напис на якому треба відобразити нове число
# canvas канвас на якому треба вивести всі значення у вигляді діаграми
# list список елементів що будуть виводитись
def addElement(value, label, canvas, list):
    label.config(text=label["text"]+value+",") # додає на напис нове значення зберігаючи все що було там до цього
    list.append(int(value)) # додає новий елемент в список що передавався в якості параметру для зв'язку
    # створення словника що буде зберігати всі характеристики елементу
    element = {"value": int(value), "color": choseColor()}
    # value - саме значення що зберігатиметься для відображення при наведенні
    # color - випадковий колір, що зберігатиметься, щоб при виводі елементів і додаванні нових кольори не змінювались хаотично
    segments.append(element) # додавання словника у загальну змінну що працює з відображенням елементів
    drawData(canvas) # виклик функції що буде малювати кожне число на канвасі

colors = [f"#{r.randint(0, 25) * 10:02X}" 
              f"{r.randint(0, 25) * 10:02X}"
              f"{r.randint(0, 25) * 10:02X}" for i in range(1000)] # створення списку з 1000 унікальних кольорів
# функція що буде вибирати колір з загальних, а також повертати його і видаляти як використаний з загального списку
def choseColor():
    global colors # звернення до глобального списку кольорів
    color = r.choice(colors) # вибір одного кольору
    colors.remove(color) # видалення його з загального списку
    return color # повернення в якості результату роботи функції для використання у місці виклику

segments = [] # загальний список всіх елементів що будуть відображенні на канвасі з усіма словниками з їх властивостями

# функція, що буде відмальовувати все коло автоматично ділячи його на сегменти
# приймає канвас як агрумент щоб зберегти зв'язок з основним файлом
def drawData(canvas):
    canvas.delete(ALL) # видаляє всі елементи що вже присутні на канвасі на момент виклику
    sum_a = 0 # змінна що слідкує за заповненням кола та дозволяє малювати кожний наступний сегмент після попереднього
    sum_v = sum([el["value"] for el in segments]) # змінна що буде зберігати сумму всіх значеннь в списку що відмальовуватименться
    for el in segments: # цикл для кожного елемента в списку словників елементів з усіма їх властивостями
        el["angle"] = 100/sum_v*el["value"]* 3.6 # нова властивість що зберігає скільки градусів на колі має займати елемент
        el["arc"] = canvas.create_arc(50,50,350,350, # нова властивість що буде зберігати індекс того об'єкта арки що буде на канвасі
                                      extent= el["angle"], # кількість градусів що займатиме арка на колі
                                      start=sum_a, # відступ від початку кола для послідовного відображення сегметів
                                      fill=el["color"]) # колір сегмента що зберігався в словнику зі створення елементу
        el["start"] = sum_a # нова властивість, що запам'ятає з якого градуса починати коло
        sum_a += el["angle"] # збільшення змінної що слідкує за порядком відображення
        canvas.tag_bind(el["arc"], "<Enter>", lambda e: showData(find(e), canvas))
        # прив'язка івента(події) перетинання мишкою об'єкту на канвасі з функцією showData що збільшть візуально сегмент для користувача

# функція, що знаходить і повертає словник в якому записана інформація про сегмент до якого найблище всього знаходиться миша
def find(event):
    id = event.widget.find_closest(event.x, event.y) # пошук індексу елементу через вбудовану функцію
    for el in segments: # для кожного елемента в списку словників
        if el["arc"] == id[0]: # перевірити чи співпадає індекс зі словника зі знайденим через функцію find_closest
            return el # якщо так - то завершуємо пошук і повертаємо число
    return segments[0] # якщо ні - то на всяк випадок повертаємо перший елемент щоб не виникала помилка


last = None # глобальна змінна що слідкуватиме за тим який елемент було вибрано останнім
text = None # глобальна змінна що зберігатиме індекс тексту що відображатиметься на екрані показуючи значення сегменту

# функція що показує збільшує сегмент на канвасі коли на нього наведена миша
# el - словник, що зберігає всі необхідні данні про сегмент
# canvas - канвас на якому відбудеться зміна
def showData(el, canvas):
    global last, text # використання глобальних змінних для останнього сегмента та тексту
    if last: # якщо останній елемент не пустий і має якесь записане значення
        hideData(last, canvas) # сховати осанній елемент повернувши зображення сегменту до початкового зовнішнього вигляду
    canvas.delete(el["arc"]) # видалити з канвасу старе зображення поточного сегменту що треба збільшити
    el["arc"] = canvas.create_arc(25, 25, 375, 375, # стоверння нового сегменту що більший за попередній
                                  extent=el["angle"], # передача величини сегменту через переданий словник що зберігає цю інформацію
                                  start=el["start"], # передача кута з якого треба почати сегмент щоб зберегти порядок
                                  fill=el["color"]) # передача кольору сегменту, щоб він не поміняв колір під час відображення
    text = canvas.create_text(200, 30, text="Value:" + str(el["value"]), fill="black", font="Arial 30")
    # створення підпису що буде показувати яке значення у сегменту на який навели мишею
    last = el # запам'ятовування що саме цей елемент був останнім виділеним
    canvas.tag_bind(el["arc"], "<Leave>", lambda e: hideData(find(e), canvas)) # прив'язка функції hideData до події виходу миші з сегменту

# функція що приховує сегмент зменшуючи його до початкових розмірів коли миша вийшла з нього
def hideData(el, canvas):
    if text: # якщо текст вже був присутній на екрані
        canvas.delete(text) # видалити цей текст щоб сховати данні про сегмент що більше не виділений
    canvas.delete(el["arc"]) # видалити той збільщений сегмент що був відображений
    el["arc"] = canvas.create_arc(50, 50, 350, 350, # намалювати сегмент оригінального розміру як при ствоерння діаграми
                                  extent=el["angle"],
                                  start=el["start"],
                                  fill=el["color"])
    canvas.tag_bind(el["arc"], "<Enter>", lambda e: showData(find(e), canvas))
    # прив'язка тої ж самої функції до вже оновленого зменшеного сегмента
